{
    "template": "// Step 1: Define the attack power of each original and combined element.\nlet fireAttackPower = 25; // Fire has an attack power of 25.\nlet waterAttackPower = 30; // Water has an attack power of 30.\nlet earthAttackPower = 20; // Earth has an attack power of 20.\nlet windAttackPower = 15; // Wind has an attack power of 15.\n\n// Combined elements\nlet iceAttackPower = waterAttackPower + windAttackPower; // Ice is water + wind.\nlet lavaAttackPower = earthAttackPower + fireAttackPower; // Lava is earth + fire.\n\n// Step 2: Initialize the monster's health points (HP).\nlet monsterHP = 100; // The monster starts with 100 HP.\n\n// Step 3: Use a stack for the attack sequence, with the addition of combined elements.\nlet attackSequenceStack = ['lava', 'ice', 'fire', 'water', 'earth', 'wind']; // LIFO order\n\n// Step 4: Print the initial state of the monster's HP.\nconsole.log(`Initial monster HP: ${monsterHP}`);\n\n// Step 5: Efficiently process the attack sequence using a while loop instead of a for loop.\nwhile (attackSequenceStack.length > 0 && monsterHP > 0) {\n    let element = attackSequenceStack.pop(); // Get the last element (LIFO)\n    let attackPower = 0;\n    \n    switch (element) {\n        case 'fire':\n        case 'water':\n        case 'earth':\n        case 'wind':\n        case 'ice':\n        case 'lava':\n            attackPower = eval(element + 'AttackPower');\n            console.log(`Attacked with ${element}, monster HP: ${monsterHP -= attackPower}`);\n            break;\n        default:\n            console.log('Unknown element! Skipping attack.');\n            continue;\n    }\n    \n    // Check if the monster is defeated to proceed with the sealing process.\n    if (monsterHP <= 0) {\n        console.log('The monster is defeated!');\n        break;\n    }\n}\n\n// Step 6: Create the Philosopher's Stone as a requirement to seal the monster permanently.\n// The Philosopher's Stone can only be created when all elements have been used at least once.\nif (monsterHP <= 0) {\n    // Assuming all elements were used, the Philosopher's Stone is created.\n    console.log('Creating the Philosopher\\'s Stone from the essence of all elements...');\n    \n    // Check if the Philosopher's Stone can seal the monster.\n    let finalMove = 'usePhilosophersStone'; // The player uses the Philosopher's Stone to seal the monster.\n    if (finalMove === 'usePhilosophersStone') {\n        console.log('The monster has been permanently sealed by the Philosopher\\'s Stone and will not revive!');\n    } else {\n        // If for any reason the Philosopher's Stone wasn't used correctly,\n        // this could lead to an alternative ending or challenge.\n        monsterHP = 50; // For example, the monster revives with partial HP.\n        console.log('The monster revives with 50 HP! The Philosopher\\'s Stone was not used correctly.');\n    }\n} else {\n    console.log('The monster has survived the attacks. The Philosopher\\'s Stone cannot be created.');\n}\n\nif (monsterHP > 0) {\n    console.log('Despite your efforts, the monster remains undefeated.');\n} else {\n    console.log('Congratulations! You have vanquished the monster with the power of the elements and the Philosopher\\'s Stone.');\n}"
  }
  